// Quality Validators\n// Validate data quality and compliance for question bank items\n\nimport type { QuestionItem, ValidationResult } from '../types/questionBank';\nimport type { QUALITY_RULES } from './config';\n\nexport interface QualityRule {\n  name: string;\n  description: string;\n  severity: 'error' | 'warning' | 'info';\n  check: (item: QuestionItem) => boolean;\n  message: (item: QuestionItem) => string;\n  suggestion?: (item: QuestionItem) => string;\n}\n\nexport class QualityValidator {\n  private rules: QualityRule[];\n  private config: typeof QUALITY_RULES;\n\n  constructor(config: typeof QUALITY_RULES) {\n    this.config = config;\n    this.rules = this.initializeRules();\n  }\n\n  // Main validation method\n  async validate(item: QuestionItem): Promise<ValidationResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const suggestions: string[] = [];\n    \n    // Run all quality rules\n    for (const rule of this.rules) {\n      try {\n        const passed = rule.check(item);\n        \n        if (!passed) {\n          const message = rule.message(item);\n          const suggestion = rule.suggestion?.(item);\n          \n          if (rule.severity === 'error') {\n            errors.push(message);\n          } else if (rule.severity === 'warning') {\n            warnings.push(message);\n          }\n          \n          if (suggestion) {\n            suggestions.push(suggestion);\n          }\n        }\n      } catch (error) {\n        console.warn(`[Validator] Rule ${rule.name} failed:`, error);\n        warnings.push(`Validation rule '${rule.name}' encountered an error`);\n      }\n    }\n    \n    // Calculate quality score\n    const score = this.calculateQualityScore(item, errors, warnings);\n    \n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      score,\n      suggestions\n    };\n  }\n\n  // Initialize quality rules\n  private initializeRules(): QualityRule[] {\n    return [\n      // Required field rules\n      {\n        name: 'required-id',\n        description: 'Item must have a unique ID',\n        severity: 'error',\n        check: (item) => !!item.id && item.id.trim().length > 0,\n        message: () => 'Item ID is required',\n        suggestion: () => 'Add a unique identifier for this question item'\n      },\n      \n      {\n        name: 'required-language',\n        description: 'Item must specify a language',\n        severity: 'error',\n        check: (item) => !!item.language && this.config.allowedLanguages.includes(item.language.toLowerCase()),\n        message: (item) => `Invalid or missing language: ${item.language}`,\n        suggestion: () => `Language must be one of: ${this.config.allowedLanguages.join(', ')}`\n      },\n      \n      {\n        name: 'required-type',\n        description: 'Item must specify a question type',\n        severity: 'error',\n        check: (item) => !!item.type,\n        message: () => 'Question type is required',\n        suggestion: () => 'Specify the type of question (vocab, grammar, reading, etc.)'\n      },\n      \n      {\n        name: 'required-prompt',\n        description: 'Item must have a prompt/question',\n        severity: 'error',\n        check: (item) => !!item.prompt && item.prompt.trim().length > 0,\n        message: () => 'Question prompt is required',\n        suggestion: () => 'Add a clear question or instruction for learners'\n      },\n      \n      {\n        name: 'required-answer',\n        description: 'Item must have an answer',\n        severity: 'error',\n        check: (item) => item.answer !== undefined && item.answer !== null && item.answer !== '',\n        message: () => 'Answer is required',\n        suggestion: () => 'Provide the correct answer for this question'\n      },\n      \n      {\n        name: 'required-source',\n        description: 'Item must have source attribution',\n        severity: 'error',\n        check: (item) => !!item.source && !!item.source.name && !!item.source.license && !!item.source.attribution,\n        message: () => 'Complete source attribution is required (name, license, attribution)',\n        suggestion: () => 'Add proper source attribution for legal compliance'\n      },\n      \n      // Content quality rules\n      {\n        name: 'prompt-length',\n        description: 'Prompt should be appropriate length',\n        severity: 'warning',\n        check: (item) => item.prompt && item.prompt.length >= 10 && item.prompt.length <= 500,\n        message: (item) => `Prompt length (${item.prompt?.length || 0}) may be too ${(item.prompt?.length || 0) < 10 ? 'short' : 'long'}`,\n        suggestion: (item) => (item.prompt?.length || 0) < 10 \n          ? 'Consider adding more context to make the question clearer'\n          : 'Consider shortening the prompt for better readability'\n      },\n      \n      {\n        name: 'explanation-present',\n        description: 'Items should include explanations',\n        severity: 'warning',\n        check: (item) => !!item.explanation && item.explanation.trim().length > 0,\n        message: () => 'Missing explanation',\n        suggestion: () => 'Add an explanation to help learners understand the answer'\n      },\n      \n      {\n        name: 'tags-present',\n        description: 'Items should have relevant tags',\n        severity: 'warning',\n        check: (item) => !!item.tags && item.tags.length > 0,\n        message: () => 'No tags specified',\n        suggestion: () => 'Add relevant tags to help categorize and search for this item'\n      },\n      \n      {\n        name: 'multiple-choice-validation',\n        description: 'Multiple choice questions should have valid choices',\n        severity: 'error',\n        check: (item) => {\n          if (!item.choices) return true; // Not a multiple choice question\n          if (item.choices.length < 2) return false;\n          if (typeof item.answer === 'number' && (item.answer < 0 || item.answer >= item.choices.length)) return false;\n          return true;\n        },\n        message: (item) => {\n          if (!item.choices || item.choices.length < 2) return 'Multiple choice questions need at least 2 choices';\n          return 'Answer index is out of range for the provided choices';\n        },\n        suggestion: () => 'Ensure you have 2-4 choices and the answer index is valid'\n      },\n      \n      // Content appropriateness rules\n      {\n        name: 'profanity-check',\n        description: 'Content should be appropriate for learners',\n        severity: 'error',\n        check: (item) => {\n          if (!this.config.profanityCheck) return true;\n          // Simplified profanity check - in reality would use a proper filter\n          const content = `${item.prompt} ${item.explanation || ''} ${JSON.stringify(item.choices || [])}`;\n          return !this.containsProfanity(content);\n        },\n        message: () => 'Content may contain inappropriate language',\n        suggestion: () => 'Review and remove any inappropriate content'\n      },\n      \n      {\n        name: 'banned-words',\n        description: 'Content should not contain banned words',\n        severity: 'warning',\n        check: (item) => {\n          if (!this.config.bannedWords || this.config.bannedWords.length === 0) return true;\n          const content = `${item.prompt} ${item.explanation || ''}`.toLowerCase();\n          return !this.config.bannedWords.some(word => content.includes(word.toLowerCase()));\n        },\n        message: () => 'Content contains words from the banned list',\n        suggestion: () => 'Consider rephrasing to avoid banned terms'\n      },\n      \n      // Difficulty and level rules\n      {\n        name: 'difficulty-consistency',\n        description: 'Difficulty metrics should be consistent with level',\n        severity: 'warning',\n        check: (item) => {\n          if (!item.difficulty || !item.level) return true;\n          \n          const expectedDifficulty = this.getExpectedDifficulty(item.level);\n          const actualDifficulty = item.difficulty.overallDifficulty || 5;\n          \n          // Allow some variance (±2 points)\n          return Math.abs(actualDifficulty - expectedDifficulty) <= 2;\n        },\n        message: (item) => {\n          const expected = this.getExpectedDifficulty(item.level);\n          const actual = item.difficulty?.overallDifficulty || 5;\n          return `Difficulty (${actual}) doesn't match level expectation (${expected})`;\n        },\n        suggestion: () => 'Review the difficulty calculation or level assignment'\n      },\n      \n      // Type-specific rules\n      {\n        name: 'vocabulary-word-present',\n        description: 'Vocabulary items should specify the target word',\n        severity: 'warning',\n        check: (item) => {\n          if (item.type !== 'vocab') return true;\n          const vocabItem = item as any;\n          return !!vocabItem.word && vocabItem.word.trim().length > 0;\n        },\n        message: () => 'Vocabulary items should specify the target word',\n        suggestion: () => 'Add the target vocabulary word to the item data'\n      },\n      \n      {\n        name: 'reading-passage-present',\n        description: 'Reading items should have a passage',\n        severity: 'error',\n        check: (item) => {\n          if (item.type !== 'reading') return true;\n          const readingItem = item as any;\n          return !!readingItem.passage && readingItem.passage.trim().length > 0;\n        },\n        message: () => 'Reading items must include a passage',\n        suggestion: () => 'Add the reading passage that learners will comprehend'\n      },\n      \n      // License compliance rules\n      {\n        name: 'license-compliance',\n        description: 'Source license must be properly specified',\n        severity: 'error',\n        check: (item) => {\n          if (!item.source) return false;\n          const validLicenses = ['CC-BY', 'CC-BY-SA', 'CC-BY-NC', 'CC-BY-NC-SA', 'EDRDG', 'Public-Domain', 'Other'];\n          return validLicenses.includes(item.source.license);\n        },\n        message: (item) => `Invalid license: ${item.source?.license}`,\n        suggestion: () => 'Use a valid open source license identifier'\n      },\n      \n      {\n        name: 'attribution-format',\n        description: 'Attribution should follow proper format',\n        severity: 'warning',\n        check: (item) => {\n          if (!item.source?.attribution) return false;\n          // Check for basic attribution elements\n          const attribution = item.source.attribution.toLowerCase();\n          return attribution.includes('by') || attribution.includes('©') || attribution.includes('copyright');\n        },\n        message: () => 'Attribution may not follow standard format',\n        suggestion: () => 'Include author/creator information in the attribution'\n      }\n    ];\n  }\n\n  // Calculate quality score based on validation results\n  private calculateQualityScore(item: QuestionItem, errors: string[], warnings: string[]): number {\n    let score = 1.0;\n    \n    // Deduct for errors (major issues)\n    score -= errors.length * 0.3;\n    \n    // Deduct for warnings (minor issues)\n    score -= warnings.length * 0.1;\n    \n    // Bonus for good practices\n    if (item.explanation && item.explanation.length > 20) score += 0.05;\n    if (item.tags && item.tags.length >= 3) score += 0.05;\n    if (item.media && item.media.length > 0) score += 0.05;\n    if (item.difficulty && item.difficulty.overallDifficulty) score += 0.05;\n    \n    // Type-specific bonuses\n    if (item.type === 'vocab') {\n      const vocabItem = item as any;\n      if (vocabItem.word) score += 0.05;\n      if (vocabItem.pronunciation) score += 0.05;\n      if (vocabItem.examples && vocabItem.examples.length > 0) score += 0.05;\n    }\n    \n    if (item.type === 'reading') {\n      const readingItem = item as any;\n      if (readingItem.passage) score += 0.05;\n      if (readingItem.wordCount && readingItem.wordCount > 0) score += 0.05;\n    }\n    \n    // Ensure score is between 0 and 1\n    return Math.max(0, Math.min(1, score));\n  }\n\n  // Helper methods\n  private containsProfanity(text: string): boolean {\n    // Simplified profanity detection - in reality would use a comprehensive filter\n    const commonProfanity = ['damn', 'hell', 'shit', 'fuck', 'bitch', 'ass'];\n    const lowerText = text.toLowerCase();\n    return commonProfanity.some(word => lowerText.includes(word));\n  }\n\n  private getExpectedDifficulty(level: any): number {\n    if (level.system === 'CEFR') {\n      const levelMap: Record<string, number> = {\n        'A1': 2, 'A2': 3, 'B1': 5, 'B2': 6, 'C1': 8, 'C2': 9\n      };\n      return levelMap[level.level] || 5;\n    } else if (level.system === 'JLPT') {\n      const levelMap: Record<string, number> = {\n        'N5': 2, 'N4': 4, 'N3': 5, 'N2': 7, 'N1': 9\n      };\n      return levelMap[level.level] || 5;\n    } else if (level.system === 'heuristic') {\n      return level.level || 5;\n    }\n    return 5;\n  }\n\n  // Batch validation\n  async validateBatch(items: QuestionItem[]): Promise<{\n    results: ValidationResult[];\n    summary: {\n      total: number;\n      valid: number;\n      invalid: number;\n      averageScore: number;\n      commonIssues: Array<{ issue: string; count: number }>;\n    };\n  }> {\n    console.log(`[Validator] Validating batch of ${items.length} items...`);\n    \n    const results: ValidationResult[] = [];\n    const issueCount = new Map<string, number>();\n    \n    for (const item of items) {\n      const result = await this.validate(item);\n      results.push(result);\n      \n      // Count issues for summary\n      [...result.errors, ...result.warnings].forEach(issue => {\n        issueCount.set(issue, (issueCount.get(issue) || 0) + 1);\n      });\n    }\n    \n    const valid = results.filter(r => r.isValid).length;\n    const averageScore = results.reduce((sum, r) => sum + r.score, 0) / results.length;\n    \n    const commonIssues = Array.from(issueCount.entries())\n      .map(([issue, count]) => ({ issue, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10); // Top 10 issues\n    \n    return {\n      results,\n      summary: {\n        total: items.length,\n        valid,\n        invalid: items.length - valid,\n        averageScore,\n        commonIssues\n      }\n    };\n  }\n\n  // Rule management\n  addRule(rule: QualityRule): void {\n    this.rules.push(rule);\n  }\n\n  removeRule(ruleName: string): boolean {\n    const index = this.rules.findIndex(rule => rule.name === ruleName);\n    if (index >= 0) {\n      this.rules.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  getRules(): QualityRule[] {\n    return [...this.rules];\n  }\n\n  // Configuration\n  updateConfig(newConfig: Partial<typeof QUALITY_RULES>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  getConfig(): typeof QUALITY_RULES {\n    return { ...this.config };\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ status: 'healthy' | 'degraded'; details: any }> {\n    return {\n      status: 'healthy',\n      details: {\n        rulesCount: this.rules.length,\n        configValid: !!this.config,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n}\n